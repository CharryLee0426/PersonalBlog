---
title: 几道位运算题目
date: 2021-08-16
tag: 算法
categories: 刷题
top: false
mathjax: true 
---

## 记录几道位运算算法题

> 计算机所有数据、程序本质上都是一串串二进制数，了解二进制数的运算规律和原理理所当然的是每个程序员应该掌握的知识，所以记录一下最近做的几道位运算题目以备以后回顾之用。

### 0. 位运算的简要回顾

位运算（也叫逻辑运算）最基本的运算有**与运算、或运算、取反运算、异或运算、左移运算、算术右移运算、逻辑右移运算**。一般的编程语言中都定义了这些运算的运算符。其他的位运算，比如**同或运算**可以通过以上这些基本运算得到（通过一组不同的运算可以得到其他所有运算，这组运算就是这类运算的**完备集**，不知不觉复习了一遍离散）。下面的表格总结了各个运算的真值表。

**与运算**

| T/F  | 0    | 1    |
| ---- | ---- | ---- |
| 0    | F    | F    |
| 1    | F    | T    |

**或运算**

| T/F  | 0    | 1    |
| ---- | ---- | ---- |
| 0    | F    | T    |
| 1    | T    | T    |

**取反运算**

0 --> 1 ; 1 --> 0

**异或运算**

| T/F  | 0    | 1    |
| ---- | ---- | ---- |
| 0    | F    | T    |
| 1    | T    | F    |

**左移运算（以 8 位补码整数举例）**

> 0000 1000		左移两位后
>
> 0010 0000
>
> 1111 1000		左移两位后
>
> 1110 0000

**算术右移运算（以 8 位补码整数举例）**

> 0000 1000		右移两位后
>
> 0000 0010
>
> 1111 1000		右移两位后
>
> 1111 1110

**逻辑右移运算（以 8 位补码整数举例）**

> 0000 1000		右移两位后
>
> 0000 0010
>
> 1111 1000		右移两位后
>
> 0011 1110

同时，位运算也要结合到计科的两门基础课，离散数学和数字电路。一种很好的求逻辑表达式的方法是**卡诺图**。作为科班出身的我们一定要熟练掌握。和卡诺图相关的一个很重要的知识点是**格雷码（Gray Code）**,这些知识的掌握标志着我们和非科班出身的人的区别。

下表总结了 Java 中的位运算符

| 运算符 | 定义     |
| ------ | -------- |
| &      | 与       |
| \|     | 或       |
| ~      | 非       |
| ^      | 异或     |
| <<     | 左移     |
| >>     | 算术右移 |
| >>>    | 逻辑右移 |

 ### 1. 求出每位数中二进制表示里一的个数

我们可以很明显的联想到任意一位数与 1 相与的结果就是该数最低位，可以看下面的分析

> 0110 1011	&
>
> 0000 0001

那么我们可以从右往左通过这样的方式判断，对于要判断的数来说，标尺不动的话应该右移，注意这里应该是逻辑右移，这是因为计算机中的数用补码表示，所以可以确定 0 的二进制位全为0，而算术右移当数最高位为 1，也就是为负数时右移高位补 1 而不是 0。我们用一个数存储结果并返回就可以了。这个题很简单，完整代码如下：

```
public int hammingWeight(int n) {
        int res = 0;
        while (n != 0) {
            res += n & 1;
            n >>>= 1;
        }
        return res;
    }
```

从方法名也可以看出些这道题的背景：汉明距离（Hamming Weight）。汉明距离是数据传输过程中检错和纠错的重要理论基础。我的理解中，这个距离有点像二进制间几何距离的意思。在计网和计组中都有广泛的应用（就是检错码和纠错码）。

### 2. 找出数组中仅出现过一次的两个数字

先看一个基本的问题：如何找出数组中仅出现过一次的数字。比如在 [1, 1, 3, 3, 4] 中找出 4。

这里需要了解一个公式，两个相同的数的异或运算为0，0 和 0 的异或还是0。那么只要将各个数依次异或就是答案了。

不过，这道题比上面说的情况要复杂一些，因为有两个数仅出现过一次。假设 x 和 y 只出现过一次，所有元素异或的结果就是 x 和 y 的异或，得不到结果。我们很自然的想法就是能不能将这些数字按某些规律分成两组。我们通过以上的例子探究，在之前的例子中加入元素 5。

> 0001
>
> 0001
>
> 0011
>
> 0011
>
> 0100
>
> 0101

在要找的两个数字二进制表示中，可以根据首位不同位将其分为两组，在此例中，就是按照最低位来分，则分出两组

> 第一组：
>
> 0001
>
> 0001
>
> 0011
>
> 0011
>
> 0101
>
> 第二组：
>
> 0100

则遍历整个数组两次就可以将这两个数找出来。

这个分类依据的方法可以这样做，即找出最低不同位，假设 x 是第一次遍历结果，m 表示最低不同位则可令 m 初值为 1。代码如下

```
while ((x & m) == 0) {
		m <<= 1;
}
```

这个 m 的二进制表示中仅有一个 1，这个 1 所在位置就是最低不同位的位置。然后再遍历一遍，这边就可以分类同时找出 x 和 y 了。完整代码如下

```
public int[] singleNumbers(int[] nums) {
        int x = 0, y = 0, n = 0, m = 1;
        for (int num : nums) {
            n ^= num;
        }

        while ((m & n) == 0) {  // 找出最低的不同位
            m <<= 1;
        }

        for (int num : nums) {
            if ((num & m) == 0) {
                x ^= num;
            } else {
                y ^= num;
            }
        }
        return new int[] {x, y};
		}
```

这道题和上一道题相比起来更多的就是对位运算的考察，而缺少一些来自于实际的背景。

### 3. 从其余数字出现三次的数组中找出仅出现一次的数字

这一题和第二题是相似的，也是寻找仅出现一次的数字，但是整个数组的情况发生了变化，除一个数字出现一次外，其余数字都出现了三次。例如 [3, 3, 5, 3] 这样的数组。

对于这样的数组，用之前的分组求异或或者直接求异或肯定是不行的，可以试想，直接异或的结果就是出现所有数的结果的异或，根本对解决问题没有帮助。那么，我们就要从结果的二进制数开始分析。对于其余数字，他们相同二进制位出现 1 的个数只可能是 3 的倍数。那么，对各个位置处的 1 的出现次数进行统计并将该结果对 3 求余，就可以得到想要的结果。就以例子中的数组举例。

> ​	0011
>
> ​	0011
>
> ​	0101
>
> ​	0011
>
> \----------------
>
> ​	0134			% 3
>
> \----------------
>
> ​	0101

可以看到将 5 成功找了出来。那么现在需要做的就是代码实现这个过程，一种较好的方法是**有限状态机法**。这个方法在之前字符串匹配的时候用过（这个题很好，hard 难度，难在情况很多且相互之间的联系很乱），就是找出各个状态的转移关系。对 3 求余的结果只能是 0, 1, 2，它们的转换关系是这样的

> 0 --> 1 --> 2 --> 0 ...
>
> 每个节点拥有一个自回路，作为输入 0 时的反应。

我们把它换为二进制数显示的话是这样的

> 00 --> 01 --> 10 --> 00 ...
>
> 和上面的一样

实际上，这个 2 状态是不可能出现的，如果出现 2 说明有两个仅出现一次的数，这个 2 状态实际上是作为中间的转移状态使用的。

我们将 00 中的低位称为 one，将高位称为 two，设输入的二进制位为 n，列出一个表格方便分析，其中每个位置的 one 最终结果形成的数就是结果。

| n    | two  | one  | two(new) | one(new) |
| ---- | ---- | ---- | -------- | -------- |
| 0    | 0    | 0    | 0        | 0        |
| 0    | 0    | 1    | 0        | 1        |
| 0    | 1    | 0    | 1        | 0        |
| 1    | 0    | 0    | 0        | 1        |
| 1    | 0    | 1    | 1        | 0        |
| 1    | 1    | 0    | 0        | 0        |

我们要从低位到高位开始求，所以先求 on 关于 n t o 的关系，列出卡诺图

| o\ n/t | 00   | 01   | 11   | 10   |
| ------ | ---- | ---- | ---- | ---- |
| 0      | 0    | 0    | 0    | 1    |
| 1      | 1    | x    | x    | 0    |

找出其中两个为  1 的情况进行化简得到

```
one = n ^ one & ~two
```

再找 tn 关于 n, t, on 的关系，列出卡诺图

| on\ n/t | 00   | 01   | 11   | 10   |
| ------- | ---- | ---- | ---- | ---- |
| 0       | 0    | 1    | 0    | 1    |
| 1       | 0    | x    | x    | 0    |

找出其中两个为 1 的情况进行化简得到

```
two = n ^ two & ~one
```

这两个式子不能更换顺序。各个位置这个过程可以随着元素遍历并行进行。所以完整程序如下

```
public int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for (int num : nums) {
            ones = ones ^ num & ~twos;
            twos = twos ^ num & ~ones;
        }
        return ones;
    }
```

这道题我认为是位运算这几道题里最难的一道题，同样的也是最有意思的一道题。这个题还有统计各位 1 的个数的传统解法。

### 4. 实现不使用算术运算符的加法

这道题可谓是深入计算机本质的一道题，事实上，计算机一切运算都是通过逻辑运算实现的，算术运算可以视作逻辑运算的封装或接口。想做这道题，就得求出一位全加器的逻辑表达式。

| a    | b    | d    | c    |
| ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    |
| 0    | 1    | 1    | 0    |
| 1    | 0    | 1    | 0    |
| 1    | 1    | 0    | 1    |

不难看出，c = (a & b) << 1，d = a ^ b。

那么将新的 c 值传给 b，d 值传给 a，b 值在一轮循环后就是上一次运算的进位，a 值就是不算进位的加法结果，一直循环，当 b 等于 0 时，也就是进位全部处理完没有进位时 a 就是 a + b 的结果。

搞清楚运算逻辑，写出代码，代码如下

```
public int add(int a, int b) {
        int c = 0;
        while (b != 0) {
            c = (a & b) << 1;
            a = a ^ b;
            b = c;
        }
        return a;
    }
```

这道题考的是计算机底层的理解，科班出身的相比起非电子类转行的人的优势就是对计算机底层和硬件有更多的了解，对于加法器和进一步的运算器（ALU）的内容，可以看计组的相关书籍学习，这里正在看的一本书是《计算机组成与设计：软/硬件接口》。

### 5. 写在最后

这是我写的第一篇总结的文章，自从从学校出来很久没有这么认真的总结过东西了。希望这种总结算法题、技术点的小文章可以一直写下去。
