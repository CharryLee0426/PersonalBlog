---
title: 诸多限制的高斯求和
date: 2021-07-29
tag: 算法
categories: 刷题
top: false
mathjax: false
---

## 诸多限制的高斯求和

### 0. 题目

试求 1+2+3+...+n 的值。要求：**不能使用 1) times & division; 2) for & while loop; 3) if else and any other similar keywords; 4) switch, case and so on; 4) condition justice sentences; 5) any other keywords except basic keywords**。

### 1. 分析

如果只是让求 1+2+3+...+n 的值的话，这是一道很弱智的题目，是个人都能做出来。但是现在加了许多限制，那么许多方法是不能使用的。下面逐条分析，并逐步探寻解法。

#### a. 高斯解法

少年高斯的经典解法 `res = (n+1) * n / 2`。这个解法需要用到乘除法，用 java 解题的话是解不出来的，因为`n * (n+1)` 这个式子必须用到乘除法，所以排除。但是在 c++ 下这个方法是可行的。这个放到最后再说。

#### b. 循环法

由题目所知，禁止使用 for 和 while 语句，没有了循环的可能性，所以这个方法也是不现实的，但是循环也该还有其他的实现方式。。。

#### c. 递归法

递归的本质是调用堆栈，可以实现循环，但是又出现了一个问题，递归必须要有终止条件使其递归有限次后跳出堆栈，这时就需要用到条件判断语句，可是这里条件判断语句是禁止的，那怎么办呢？

所以，问题的关键在于：**如何终止循环？**

这时我们就需要联想到一个高级编程语言的特性（这个脑洞说实话挺大的）`&&`和`||`的短路效应。

### 2. `&&`和`||`的短路效应

我们以 `&&` 来说明短路效应。对于布尔表达式`A && B`来说，一旦确定 A 为假，那么这个式子一定为假，现代的高级编程语言为了提高效率当执行了 A 以后，若 A 为假就不再执行 B，而是直接向下执行。这就是**`&&`和`||`的短路效应**。

那么我们怎么利用这个效应呢？我们可以通过下列语句来实现递归的终止。

```java
// res 为该类的一个成员变量，因为需要存储过程中 res 的值。

boolean x = n > 1 && sumNums(n - 1) > 0;
res += n;
return res;
```

我们来分析，正常用递归的话，我们把 n <= 1当作是递归的终止条件，n = 1的时候直接返回1。那么看 x 的表达式，当 n = 1 时，n > 1为假，所以 x 肯定为 false，由于短路效应，之后的 sumNums(n - 1)就不会被执行。这就达到了不使用循环的条件下实现递归的终止。需要注意的一点是，返回的 res 因为求每次递归的时候都需要将其保存起来，所以将 res 定义成该类的成员变量，达到存储的目的。

完整可运行的代码如下。

```java
class Solution {
    int res = 0;
    public int sumNums(int n) {
        boolean x = n > 1 && sumNums(n - 1) > 0;
        res += n;
        return res;
    }
  
  	// test
    public static void main(String[] args) {
      	int sum = new Solution.sumNums(3);		// 6
    }
}
```

如果不想用 res 这个成员变量存中间值，而是直接给了 n，那么可以使用以下方法。

```java
class Solution {
    public int sumNums(int n) {
        boolean x = n > 1 && (n += sumNums(n - 1)) > 0;
        return n;
    }
}
```

### 3. 总结

这道题是没有什么实战意义的，毕竟没有什么工作会让你用这么奇葩的方法实现一个循环。这个面试题主要考察的是临场发挥的能力，这道题回答的好将会给面试官带来特别好的形象。因为这个题给了面试官不止出众的编程能力这一个录用你的 point。这种能力的背后是对语言特性的熟练掌握，只有对语言的特性了如指掌，做这个脑筋急转弯题才会得心应手。

### 4. 总结

这道题 官方 和 K神 用的都是递归的方法来做的。还有其他的一些方法，也是不错的，不过没有这个方法这么符合题意。不能说没答出来，但是在面试官心中这些答案总是有缺憾的。

#### 1) 利用 try-catch

这种方法是利用了 try-catch 来做的，解答者将这个语法特性当作 if 判断来用去写递归的终止条件。这个解答还是不错的，不过值得商榷的一点是 try-catch 也算是 java 里的关键字，而题目中明确不能使用除基本关键字以外的关键字。不过给出这个答案，这道题就算是合格的了，只能说不是完美。

#### 2) 创建一个 char 的二维数组

这个解法只能说很离谱，就是高斯解法的奇葩实现。首先，创建一个 n * (n+1) 的二维数组，为了降低数组占用内存，数组元素我们定义为 char（char 数据一个只占一字节）。然后用`sizeof()`函数计算出这个二维数组的元素个数，之后返回这个数右移一位的结果。

完整代码如下。

```c++
class Solution {
public:
    int sumNums(int n) {
         bool arr[n][n+1];
         return sizeof(arr)>>1;
    }
};
```

这个是真的秀到家了，连面试官都想给你个大拇哥。不过这个解法还是有一定的局限性的，首先，我在 java 找不到`sizeof()`的替代方法，其次，如果面试官深究起这个`sizeof()`的内部实现，其实这也算是用了乘法了吧。
